TCP/IP - serial шлюз для протокола ACP.
Приложение представляет собой комбинацию из TCP-сервера (один порт) и клиента 
последовательного порта (несколько портов). Получив запрос по TCP/IP, приложение
сверяет идентификатор сетевого объекта (noid) и команду с заданными в настройках. Для GET-команды,
если эта команда используется для автоматического опроса, то возвращяет ответ 
клиенту из буфера, в котором уже лежит ответ на эту команду. Если нет, то 
пересылает запрос в последовательный порт, а получив ответ из последовательного 
порта, сверяет идентификатор сетевого объекта и контрольную сумму, а затем  пересылает его 
TCP/IP-клиенту. SET-команду пересылает в последовательный порт.
Количество отслеживаемых идентификаторов сетевых объектов и команд для них не ограничено, номера идентификаторов 
должны быть уникальными. Количество используемых последовательных портов не ограничено.
1 Установка
1.1 Требования
Приложение должно работать в ОС, поддерживающей стандарт POSIX. Скрипт-установщик
работает в командной оболочке bash.
1.2 Настройки:
- место установки исполняемого файла: файл build.sh константа INST_DIR
- место установки файла конфигурации: файл build.sh константа CONF_DIR (должна соответствовать CONF_DIR из main.h)
1.3 Команды для установки:
cd gwst
chmod +x ./build.sh
Полная установка:
sudo ./build.sh full
Для тестирования (файлы не копируются за пределы текущей папки):
./build.sh part_debug

2 Настройка перед запуском
файл ./config/app.tsv:
	port - номер порта TCP/IP сервера,
	tcp_conn_num_max - максимальное количество потоков для обслуживания соединений TCP/IP-сервера (для каждого нового соединения, если
	нет свободного обслуживающего потока, то создается новый).
файл ./config/serial.tsv:
	name - имя файла последовательного порта (приложение ищет в папке /dev файл с таким именем),
	rate - скорость последовательного порта,
	config - конфигурация последовательного порта (5, 6, 7, 8) && (N, O, E, n, o, e) && (1, 2).
	В этом файле можно задать несколько последовательных портов. 
В файле ./config/noid/items.tsv нужно перечислить сетевые идентификаторы, которые будут использоваться и дать им ссылки
на файлы с настройками интерфейса:
	id - идентификатор сетевого объекта,
	iget - название файла (из папки ./config/noid/interface/get/interval/) с интерфейсом автоматического опроса сетевого объекта.
	Автоматический опрос позволяет ускорить обслуживание TCP-клиентов, которые в таком случае, сразу получают ответ из буфера, не
	ожидая ответа по последовательному интерфейсу. Идентификаторы всех сетевых объектов, заданные в этом файле будут автоматически найдены приложением сразу после
	его запуска (если они существуют) на последовательных портах. И, тогда запрос для определенного объекта будет отправлен через последовательный порт, на
	котором раннее был найден этот объект.
В папке ./config/noid/interface/get/interval можно создать файл формата TSV и в нем определить команды для автоматического опроса сетевых объектов ведомых устройств:
	command - имя GET-команды (см. ./lib/ACP/command/main.h - список всех команд);
	interval_s - интервал опроса, секунды;
	interval_ns - интервал опроса, наносекунды.
Автоматический опрос сетевых объектов позволяет значительно ускорить обслуживание 
TCP-клиентов за счет исключения ожидания передачи данных по последовательному порту. 
Команды, 
3 Запуск
При полной установке запускается автоматически, вместе с операционной системой.
sudo gwst
Если приложение установлено для тестирования:
sudo ./gwst_dbg

4 Использование
4.1 Терминал
Чтобы прочитать данные с определенных каналов, можно использовать утилиту netcat:
printf "<?;24;1>" | nc 127.0.0.1 49188
	, где
		< - начало сообщения,
		? - знак запроса,
		24 - команда CMD_GETR_CHANNEL_FTS,
		; - разделитель,
		1 - идентификатор сетевого объекта,
		> - конец сообщения.
ответ:
<!;1;33.180;562067385;570982444;1>
формат ответа:
<знак_ответа;идентификатор_сетевого_объекта;измеренная_величина;время_с;время_нс;статус>
4.2. Веб-браузерные графические интерфейсы пользователя:
Конфигуратор для различных модулей:
https://github.com/arinichevN/wui
Для опроса датчиков:
https://github.com/arinichevN/monitor_clt
Для пошагового регулирования:
https://github.com/arinichevN/wstp
